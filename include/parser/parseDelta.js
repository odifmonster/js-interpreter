/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */

import {
  mkNumber, mkBoolean, mkIdent, mkEmpty, mkBinop,
  mkUnop, mkAugBinop, mkAugUnop, mkBlock,
  buildPreUnopTree, buildPostUnopTree, buildBinopTree,
  buildCallExp, buildFuncExp,
  buildStmt, buildInitVarStmt, buildIfStmt, buildWhileStmt,
  buildReturnStmt
} from "./treeFuncs.js";

// GENERATED BY src/generators/gengram.py

export const GRAMMAR = {
  atom_e: [
    { token: "NUMBER", action: tok => mkNumber(parseFloat(tok.value)) },
    { token: "TRUE_TOK", action: _ => mkBoolean(true) },
    { token: "FALSE_TOK", action: _ => mkBoolean(false) },
    { token: "IDENT", action: tok => mkIdent(tok.value) },
  ],
  paren_e: [
    {
      rule: [
        "lparen",
        "func_e",
        "rparen",
      ],
      action: res => res[1]
    },
    {
      rule: [
        "atom_e",
      ],
      action: res => res[0]
    },
  ],
  lparen: [
    { token: "LPAREN", action: mkEmpty },
  ],
  rparen: [
    { token: "RPAREN", action: mkEmpty },
  ],
  arg_e: [
    {
      rule: [
        "lparen",
        {
          kind: "opt",
          symbols: ["comma_e"]
        },
        "rparen",
      ],
      action: res => res.length === 2 ? [] : res[1]
    },
  ],
  call_e: [
    {
      rule: [
        "paren_e",
        {
          kind: "star",
          symbols: ["arg_e"]
        },
      ],
      action: res => res.length === 1 ? res[0] : buildCallExp(res)
    },
  ],
  postfix_e: [
    {
      rule: [
        "call_e",
        {
          kind: "star",
          symbols: ["postfix_op"]
        },
      ],
      action: buildPostUnopTree
    },
  ],
  postfix_op: [
    { token: "PLUS2", action: _ => mkAugUnop("POSTINC") },
    { token: "MINUS2", action: _ => mkAugUnop("POSTDEC") },
  ],
  prefix_e: [
    {
      rule: [
        "prefix_op",
        "prefix_e",
      ],
      action: buildPreUnopTree
    },
    {
      rule: [
        "postfix_e",
      ],
      action: res => res[0]
    },
  ],
  prefix_op: [
    { token: "EXCLAM", action: _ => mkUnop("LOGNOT") },
    { token: "TILDE", action: _ => mkUnop("BITNOT") },
    { token: "PLUS1", action: _ => mkUnop("POS") },
    { token: "MINUS1", action: _ => mkUnop("NEG") },
    { token: "PLUS2", action: _ => mkAugUnop("PREINC") },
    { token: "MINUS2", action: _ => mkAugUnop("PREDEC") },
  ],
  pow_e: [
    {
      rule: [
        "prefix_e",
        {
          kind: "opt",
          symbols: ["pow_op", "pow_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  pow_op: [
    { token: "STAR2", action: _ => mkBinop("EXPN") },
  ],
  prod_e: [
    {
      rule: [
        "pow_e",
        {
          kind: "star",
          symbols: ["prod_op", "pow_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  prod_op: [
    { token: "STAR1", action: _ => mkBinop("MULT") },
    { token: "SLASH", action: _ => mkBinop("DIV") },
    { token: "MODULO", action: _ => mkBinop("MOD") },
  ],
  sum_e: [
    {
      rule: [
        "prod_e",
        {
          kind: "star",
          symbols: ["sum_op", "prod_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  sum_op: [
    { token: "PLUS1", action: _ => mkBinop("ADD") },
    { token: "MINUS1", action: _ => mkBinop("SUB") },
  ],
  shift_e: [
    {
      rule: [
        "sum_e",
        {
          kind: "star",
          symbols: ["shift_op", "sum_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  shift_op: [
    { token: "LANGLE2", action: _ => mkBinop("LSHIFT") },
    { token: "RANGLE2", action: _ => mkBinop("RSHIFT") },
  ],
  compare_e: [
    {
      rule: [
        "shift_e",
        {
          kind: "star",
          symbols: ["compare_op", "shift_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  compare_op: [
    { token: "LANGLE1", action: _ => mkBinop("LT") },
    { token: "LANGLE1_EQ", action: _ => mkBinop("LTEQ") },
    { token: "RANGLE1", action: _ => mkBinop("GT") },
    { token: "RANGLE1_EQ", action: _ => mkBinop("GTEQ") },
  ],
  iseq_e: [
    {
      rule: [
        "compare_e",
        {
          kind: "star",
          symbols: ["iseq_op", "compare_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  iseq_op: [
    { token: "EQ2", action: _ => mkBinop("ISEQ") },
    { token: "EXCLAM_EQ", action: _ => mkBinop("NOTEQ") },
  ],
  bitand_e: [
    {
      rule: [
        "iseq_e",
        {
          kind: "star",
          symbols: ["bitand_op", "iseq_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  bitand_op: [
    { token: "AMPER1", action: _ => mkBinop("BITAND") },
  ],
  bitxor_e: [
    {
      rule: [
        "bitand_e",
        {
          kind: "star",
          symbols: ["bitxor_op", "bitand_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  bitxor_op: [
    { token: "CARET", action: _ => mkBinop("BITXOR") },
  ],
  bitor_e: [
    {
      rule: [
        "bitxor_e",
        {
          kind: "star",
          symbols: ["bitor_op", "bitxor_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  bitor_op: [
    { token: "PIPE1", action: _ => mkBinop("BITOR") },
  ],
  logand_e: [
    {
      rule: [
        "bitor_e",
        {
          kind: "star",
          symbols: ["logand_op", "bitor_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  logand_op: [
    { token: "AMPER2", action: _ => mkBinop("LOGAND") },
  ],
  logor_e: [
    {
      rule: [
        "logand_e",
        {
          kind: "star",
          symbols: ["logor_op", "logand_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  logor_op: [
    { token: "PIPE2", action: _ => mkBinop("LOGOR") },
  ],
  assign_e: [
    {
      rule: [
        "logor_e",
        {
          kind: "opt",
          symbols: ["assign_op", "func_e"]
        },
      ],
      action: buildBinopTree
    },
  ],
  assign_op: [
    { token: "EQ1", action: _ => mkAugBinop("ASSIGN") },
    { token: "STAR2_EQ", action: _ => mkAugBinop("AUGEXPN") },
    { token: "STAR1_EQ", action: _ => mkAugBinop("AUGMULT") },
    { token: "SLASH_EQ", action: _ => mkAugBinop("AUGDIV") },
    { token: "MOD_EQ", action: _ => mkAugBinop("AUGMOD") },
    { token: "PLUS_EQ", action: _ => mkAugBinop("AUGADD") },
    { token: "MINUS_EQ", action: _ => mkAugBinop("AUGSUB") },
    { token: "LANGLE2_EQ", action: _ => mkAugBinop("AUGLSHIFT") },
    { token: "RANGLE2_EQ", action: _ => mkAugBinop("AUGRSHIFT") },
    { token: "AMPER_EQ", action: _ => mkAugBinop("AUGBAND") },
    { token: "CARET_EQ", action: _ => mkAugBinop("AUGBXOR") },
    { token: "PIPE_EQ", action: _ => mkAugBinop("AUGBOR") },
  ],
  comma_e: [
    {
      rule: [
        "func_e",
        {
          kind: "star",
          symbols: ["comma", "func_e"]
        },
      ],
      action: res => res.filter(e => e.kind !== "empty")
    },
  ],
  comma: [
    { token: "COMMA", action: mkEmpty },
  ],
  param_e: [
    {
      rule: [
        "name",
        {
          kind: "star",
          symbols: ["comma", "name"]
        },
      ],
      action: res => res.filter(e => typeof e === "string")
    },
  ],
  block: [
    {
      rule: [
        "lbrace",
        "stmt_seq",
        "rbrace",
      ],
      action: mkBlock
    },
  ],
  lbrace: [
    { token: "LBRACE", action: mkEmpty },
  ],
  rbrace: [
    { token: "RBRACE", action: mkEmpty },
  ],
  arrow_args: [
    {
      rule: [
        "lparen",
        "rparen",
      ],
      action: _ => []
    },
    {
      rule: [
        "name",
      ],
      action: res => res
    },
    {
      rule: [
        "lparen",
        "param_e",
        "rparen",
      ],
      action: res => res[1]
    },
  ],
  arrow_op: [
    { token: "ARROW", action: mkEmpty },
  ],
  arrow_body: [
    {
      rule: [
        "func_e",
      ],
      action: res => [buildReturnStmt(res[0])]
    },
    {
      rule: [
        "block",
      ],
      action: res => res[0].body
    },
  ],
  func_e: [
    {
      rule: [
        "function",
        "lparen",
        {
          kind: "opt",
          symbols: ["param_e"]
        },
        "rparen",
        "block",
      ],
      action: res => res.length === 4 ? buildFuncExp([], res[3]) : buildFuncExp(res[2], res[4].body)
    },
    {
      rule: [
        "arrow_args",
        "arrow_op",
        "arrow_body",
      ],
      action: res => buildFuncExp(res[0], res[2])
    },
    {
      rule: [
        "assign_e",
      ],
      action: res => res[0]
    },
  ],
  function: [
    { token: "FUNCTION_KW", action: mkEmpty },
  ],
  stmt: [
    {
      rule: [
        "end_stmt",
      ],
      action: res => res[0]
    },
    {
      rule: [
        "func_e",
        "end_stmt",
      ],
      action: buildStmt
    },
    {
      rule: [
        "init_kw",
        "name",
        "equals",
        "func_e",
        "end_stmt",
      ],
      action: buildInitVarStmt
    },
    {
      rule: [
        "block",
      ],
      action: res => res[0]
    },
    {
      rule: [
        "if",
        "lparen",
        "func_e",
        "rparen",
        "stmt",
        {
          kind: "opt",
          symbols: ["else", "stmt"]
        },
      ],
      action: buildIfStmt
    },
    {
      rule: [
        "while",
        "lparen",
        "func_e",
        "rparen",
        "stmt",
      ],
      action: buildWhileStmt
    },
    {
      rule: [
        "return",
        "func_e",
        "end_stmt",
      ],
      action: res => buildReturnStmt(res[1])
    },
    {
      rule: [
        "function",
        "name",
        "lparen",
        {
          kind: "opt",
          symbols: ["param_e"]
        },
        "rparen",
        "block",
      ],
      action: res => res.length === 5 ? buildInitVarStmt(["const", res[1], 0, buildFuncExp([], res[4].body), 0]) : buildInitVarStmt(["const", res[1], 0, buildFuncExp(res[3], res[5].body), 0])
    },
  ],
  end_stmt: [
    { token: "SEMICOLON", action: mkEmpty },
  ],
  init_kw: [
    { token: "LET_KW", action: _ => "let" },
    { token: "CONST_KW", action: _ => "const" },
  ],
  name: [
    { token: "IDENT", action: tok => tok.value },
  ],
  equals: [
    { token: "EQ1", action: mkEmpty },
  ],
  if: [
    { token: "IF_KW", action: mkEmpty },
  ],
  else: [
    { token: "ELSE_KW", action: mkEmpty },
  ],
  while: [
    { token: "WHILE_KW", action: mkEmpty },
  ],
  return: [
    { token: "RETURN_KW", action: mkEmpty },
  ],
  stmt_seq: [
    {
      rule: [
        {
          kind: "star",
          symbols: ["stmt"]
        },
      ],
      action: res => res.filter(s => s.kind !== "empty")
    },
  ],
};